//! Syntax highlighting for source code blocks using giallo.
//!
//! This module provides syntax highlighting for code blocks when the
//! `highlighting` feature is enabled. It supports two output modes:
//!
//! - **Inline** (default): `<span style="color:#...">` — themes baked into HTML
//! - **Class**: `<span class="syntax-keyword">` — themes applied via CSS classes
//!
//! The mode is controlled by the `:highlight-css:` document attribute
//! (also accepts the legacy `:syntect-css:` attribute for backward compatibility).
//!
//! # Callout Handling
//!
//! Code blocks may contain callout references (e.g., `<1>`, `<2>`) that need
//! to be rendered as HTML elements, not as part of the highlighted code.
//! We track callout positions during text extraction and inject the proper
//! HTML (`<i class="conum" data-value="N"></i><b>(N)</b>`) after highlighting.

use std::{collections::HashMap, io::Write};

use acdc_parser::InlineNode;

use crate::Error;

/// Default light theme (giallo theme name).
pub(crate) const DEFAULT_THEME_LIGHT: &str = "github-light";
/// Default dark theme (giallo theme name).
pub(crate) const DEFAULT_THEME_DARK: &str = "github-dark";

/// CSS class prefix used for class-based syntax highlighting output.
/// Every scope token is prefixed with this so the generated classes
/// don't collide with the rest of the page's styles.
#[cfg(feature = "highlighting")]
const SYNTAX_CLASS_PREFIX: &str = "syntax-";

/// How syntax-highlighted spans are styled in the HTML output.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub(crate) enum HighlightMode {
    /// Inline `style="color:…"` attributes (default, backward-compatible).
    #[default]
    Inline,
    /// CSS class names (`class="syntax-keyword"`) — requires a `<style>` block
    /// generated by [`highlight_css`].
    Class,
}

/// Get or initialize the shared giallo `Registry`.
///
/// The registry is loaded once from the builtin dump on first use and
/// then reused for all subsequent calls.  This is thread-safe via
/// `OnceLock`.
#[cfg(feature = "highlighting")]
fn get_registry() -> &'static giallo::Registry {
    use std::sync::OnceLock;

    static REGISTRY: OnceLock<giallo::Registry> = OnceLock::new();
    REGISTRY.get_or_init(|| {
        let mut registry = giallo::Registry::builtin().unwrap_or_else(|e| {
            tracing::error!("failed to load builtin giallo registry: {e}");
            giallo::Registry::default()
        });
        registry.link_grammars();
        registry
    })
}

/// Highlight code and write HTML output.
///
/// When the `highlighting` feature is enabled, this uses giallo for syntax
/// highlighting. The `mode` parameter controls whether inline styles or CSS
/// classes are emitted. Otherwise, it outputs plain escaped text.
///
/// Callout references are preserved and rendered as proper HTML elements
/// after the highlighted code on each line.
#[cfg(feature = "highlighting")]
pub(crate) fn highlight_code<W: Write + ?Sized>(
    writer: &mut W,
    inlines: &[InlineNode],
    language: &str,
    theme_name: &str,
    mode: HighlightMode,
) -> Result<(), Error> {
    let (code, callouts) = extract_text_and_callouts(inlines);

    match mode {
        HighlightMode::Inline => {
            let registry = get_registry();
            let theme_variant = giallo::ThemeVariant::Single(theme_name);
            let options =
                giallo::HighlightOptions::new(language, theme_variant).fallback_to_plain(true);

            let highlighted = match registry.highlight(&code, &options) {
                Ok(h) => h,
                Err(e) => {
                    tracing::warn!("giallo highlighting failed for language '{language}': {e}");
                    return write_escaped_code_with_callouts(writer, inlines);
                }
            };
            render_inline(writer, &highlighted, &callouts)
        }
        HighlightMode::Class => {
            highlight_code_classed(writer, &code, &callouts, language, theme_name)
        }
    }
}

/// Render highlighted tokens as inline-style HTML spans.
///
/// Uses giallo's public API to compare each token's style against the
/// theme default and emit `<span style="color:…">` elements.
#[cfg(feature = "highlighting")]
fn render_inline<W: Write + ?Sized>(
    writer: &mut W,
    highlighted: &giallo::HighlightedCode<'_>,
    callouts: &HashMap<usize, usize>,
) -> Result<(), Error> {
    let default_style = match &highlighted.theme {
        giallo::ThemeVariant::Single(theme) => &theme.default_style,
        giallo::ThemeVariant::Dual { light, .. } => &light.default_style,
    };

    let last_line_idx = if highlighted.tokens.last().is_some_and(Vec::is_empty) {
        // giallo produces a trailing empty line for content ending with \n; skip it
        highlighted.tokens.len().saturating_sub(1)
    } else {
        highlighted.tokens.len()
    };

    for (line_idx, line_tokens) in highlighted.tokens.iter().enumerate() {
        if line_idx >= last_line_idx {
            break;
        }
        if line_idx > 0 {
            writer.write_all(b"\n")?;
        }

        for token in line_tokens {
            let escaped = html_escape(&token.text);
            let style = match &token.style {
                giallo::ThemeVariant::Single(s) => *s,
                giallo::ThemeVariant::Dual { light, .. } => *light,
            };

            if style == *default_style {
                write!(writer, "<span>{escaped}</span>")?;
            } else {
                let css = build_inline_css(&style, default_style);
                if css.is_empty() {
                    write!(writer, "<span>{escaped}</span>")?;
                } else {
                    write!(writer, "<span style=\"{css}\">{escaped}</span>")?;
                }
            }
        }

        // Append callout marker if this line has one
        if let Some(&callout_num) = callouts.get(&line_idx) {
            write!(
                writer,
                " <i class=\"conum\" data-value=\"{callout_num}\"></i><b>({callout_num})</b>"
            )?;
        }
    }

    Ok(())
}

/// Build a CSS style string from differences between a token style and the default.
#[cfg(feature = "highlighting")]
fn build_inline_css(style: &giallo::Style, default: &giallo::Style) -> String {
    use std::fmt::Write as FmtWrite;

    let mut css = String::with_capacity(40);

    if style.foreground != default.foreground {
        let _ = write!(css, "color: {};", style.foreground.as_hex());
    }
    if style.background != default.background {
        let _ = write!(css, "background-color: {};", style.background.as_hex());
    }
    if style.font_style != default.font_style {
        if style.font_style.contains(giallo::FontStyle::BOLD) {
            css.push_str("font-weight: bold;");
        }
        if style.font_style.contains(giallo::FontStyle::ITALIC) {
            css.push_str("font-style: italic;");
        }
        if style.font_style.contains(giallo::FontStyle::UNDERLINE)
            && style.font_style.contains(giallo::FontStyle::STRIKETHROUGH)
        {
            css.push_str("text-decoration: underline line-through;");
        } else if style.font_style.contains(giallo::FontStyle::UNDERLINE) {
            css.push_str("text-decoration: underline;");
        } else if style.font_style.contains(giallo::FontStyle::STRIKETHROUGH) {
            css.push_str("text-decoration: line-through;");
        }
    }

    css
}

/// Class-based highlighting using giallo's `HtmlRenderer`.
///
/// Since giallo's `HighlightedText::scopes` field is `pub(crate)`, we cannot
/// iterate tokens and produce class-based spans directly. Instead we use
/// giallo's `HtmlRenderer` with a `css_class_prefix` and then extract the
/// inner token content, stripping the outer `<pre><code>` wrapper and the
/// per-line `<span class="giallo-l">` wrappers.
#[cfg(feature = "highlighting")]
fn highlight_code_classed<W: Write + ?Sized>(
    writer: &mut W,
    code: &str,
    callouts: &HashMap<usize, usize>,
    language: &str,
    theme_name: &str,
) -> Result<(), Error> {
    let registry = get_registry();
    let theme_variant = giallo::ThemeVariant::Single(theme_name);
    let options = giallo::HighlightOptions::new(language, theme_variant).fallback_to_plain(true);

    let highlighted = match registry.highlight(code, &options) {
        Ok(h) => h,
        Err(e) => {
            tracing::warn!("giallo class-based highlighting failed for language '{language}': {e}");
            // Fallback: write escaped code with callouts
            let escaped = html_escape(code);
            write!(writer, "{escaped}")?;
            return Ok(());
        }
    };

    let renderer = giallo::HtmlRenderer {
        css_class_prefix: Some(SYNTAX_CLASS_PREFIX.to_string()),
        ..Default::default()
    };
    let render_options = giallo::RenderOptions::default();
    let html = renderer.render(&highlighted, &render_options);

    // Extract content between <code ...> and </code>
    let inner = extract_code_inner_content(&html);

    // Strip per-line <span class="giallo-l"> wrappers and insert callouts
    let lines: Vec<&str> = inner.split('\n').collect();
    for (i, line) in lines.iter().enumerate() {
        if i > 0 {
            writer.write_all(b"\n")?;
        }
        let unwrapped = strip_line_wrapper(line);
        write!(writer, "{unwrapped}")?;
        if let Some(&callout_num) = callouts.get(&i) {
            write!(
                writer,
                " <i class=\"conum\" data-value=\"{callout_num}\"></i><b>({callout_num})</b>"
            )?;
        }
    }

    Ok(())
}

/// Extract content between `<code ...>` and `</code>` from giallo's HTML output.
#[cfg(feature = "highlighting")]
fn extract_code_inner_content(html: &str) -> &str {
    // Find the end of the <code ...> opening tag
    let code_start = html.find("<code");
    let inner_start = code_start
        .and_then(|start| html.get(start..)?.find('>').map(|i| start + i + 1))
        .unwrap_or(0);
    let inner_end = html.rfind("</code>").unwrap_or(html.len());
    html.get(inner_start..inner_end).unwrap_or(html)
}

/// Strip a `<span class="giallo-l">...</span>` wrapper from a line,
/// returning just the inner token content.
#[cfg(feature = "highlighting")]
fn strip_line_wrapper(line: &str) -> &str {
    const PREFIX: &str = "<span class=\"giallo-l\">";
    const SUFFIX: &str = "</span>";

    if let Some(rest) = line.strip_prefix(PREFIX) {
        rest.strip_suffix(SUFFIX).unwrap_or(rest)
    } else {
        line
    }
}

/// Generate a CSS stylesheet for class-based syntax highlighting.
///
/// Returns the CSS rules that map `.syntax-*` classes to the colours of
/// the given theme. Embed this in a `<style>` block in the `<head>`.
#[cfg(feature = "highlighting")]
pub(crate) fn highlight_css(theme_name: &str) -> Result<String, Error> {
    let registry = get_registry();
    registry
        .generate_css(theme_name, SYNTAX_CLASS_PREFIX)
        .map_err(|e| Error::Io(std::io::Error::other(e.to_string())))
}

/// HTML-escape special characters.
fn html_escape(s: &str) -> String {
    s.replace('&', "&amp;")
        .replace('<', "&lt;")
        .replace('>', "&gt;")
        .replace('"', "&quot;")
}

/// Write HTML-escaped code with callout markers.
///
/// This is the fallback when syntax highlighting is disabled or unavailable.
fn write_escaped_code_with_callouts<W: Write + ?Sized>(
    writer: &mut W,
    inlines: &[InlineNode],
) -> Result<(), Error> {
    let (code, callouts) = extract_text_and_callouts(inlines);

    if callouts.is_empty() {
        let escaped = html_escape(&code);
        write!(writer, "{escaped}")?;
    } else {
        for (i, line) in code.split('\n').enumerate() {
            if i > 0 {
                writeln!(writer)?;
            }
            let escaped = html_escape(line);
            write!(writer, "{escaped}")?;
            if let Some(&callout_num) = callouts.get(&i) {
                write!(
                    writer,
                    "<i class=\"conum\" data-value=\"{callout_num}\"></i><b>({callout_num})</b>"
                )?;
            }
        }
    }
    Ok(())
}

/// Highlight code when the highlighting feature is not enabled.
#[cfg(not(feature = "highlighting"))]
pub(crate) fn highlight_code<W: Write + ?Sized>(
    writer: &mut W,
    inlines: &[InlineNode],
    _language: &str,
    _theme_name: &str,
    _mode: HighlightMode,
) -> Result<(), Error> {
    write_escaped_code_with_callouts(writer, inlines)
}

/// Extract text content and callout positions from inline nodes for highlighting.
///
/// Returns the code text (without callout markers) and a map of line numbers
/// to callout numbers.
fn extract_text_and_callouts(inlines: &[InlineNode]) -> (String, HashMap<usize, usize>) {
    let mut result = String::new();
    let mut callouts: HashMap<usize, usize> = HashMap::new();
    let mut current_line = 0;

    for node in inlines {
        #[allow(clippy::match_same_arms)]
        match node {
            InlineNode::VerbatimText(verbatim) => {
                for ch in verbatim.content.chars() {
                    result.push(ch);
                    if ch == '\n' {
                        current_line += 1;
                    }
                }
            }
            InlineNode::RawText(raw) => {
                for ch in raw.content.chars() {
                    result.push(ch);
                    if ch == '\n' {
                        current_line += 1;
                    }
                }
            }
            InlineNode::PlainText(plain) => {
                for ch in plain.content.chars() {
                    result.push(ch);
                    if ch == '\n' {
                        current_line += 1;
                    }
                }
            }
            InlineNode::LineBreak(_) => {
                result.push('\n');
                current_line += 1;
            }
            InlineNode::CalloutRef(callout) => {
                callouts.insert(current_line, callout.number);
            }
            InlineNode::BoldText(_)
            | InlineNode::ItalicText(_)
            | InlineNode::MonospaceText(_)
            | InlineNode::HighlightText(_)
            | InlineNode::SubscriptText(_)
            | InlineNode::SuperscriptText(_)
            | InlineNode::CurvedQuotationText(_)
            | InlineNode::CurvedApostropheText(_)
            | InlineNode::StandaloneCurvedApostrophe(_)
            | InlineNode::InlineAnchor(_)
            | InlineNode::Macro(_) => {}
            node => {
                tracing::warn!(
                    ?node,
                    "this type of node is not yet implemented for code highlighting"
                );
            }
        }
    }
    (result, callouts)
}

#[cfg(all(test, feature = "highlighting"))]
mod tests {
    use super::*;
    use acdc_parser::{CalloutRef, CalloutRefKind, Location, Verbatim};

    fn create_verbatim_inlines(content: &str) -> Vec<InlineNode> {
        vec![InlineNode::VerbatimText(Verbatim {
            content: content.to_string(),
            location: Location::default(),
        })]
    }

    fn create_callout_ref(number: usize) -> InlineNode {
        InlineNode::CalloutRef(CalloutRef {
            kind: CalloutRefKind::Explicit,
            number,
            location: Location::default(),
        })
    }

    #[test]
    fn test_extract_text_and_callouts_from_verbatim() {
        let inlines = create_verbatim_inlines("fn main() {\n    println!(\"Hello\");\n}");
        let (text, callouts) = extract_text_and_callouts(&inlines);
        assert_eq!(text, "fn main() {\n    println!(\"Hello\");\n}");
        assert!(callouts.is_empty());
    }

    #[test]
    fn test_extract_text_and_callouts_with_callouts() {
        let inlines = vec![
            InlineNode::VerbatimText(Verbatim {
                content: "let x = 1; ".to_string(),
                location: Location::default(),
            }),
            create_callout_ref(1),
            InlineNode::VerbatimText(Verbatim {
                content: "\nlet y = 2; ".to_string(),
                location: Location::default(),
            }),
            create_callout_ref(2),
            InlineNode::VerbatimText(Verbatim {
                content: "\n".to_string(),
                location: Location::default(),
            }),
        ];

        let (text, callouts) = extract_text_and_callouts(&inlines);
        assert_eq!(text, "let x = 1; \nlet y = 2; \n");
        assert_eq!(callouts.get(&0), Some(&1));
        assert_eq!(callouts.get(&1), Some(&2));
        assert_eq!(callouts.len(), 2);
    }

    #[test]
    #[allow(clippy::expect_used)]
    fn test_highlight_code_with_callouts() -> Result<(), Error> {
        let inlines = vec![
            InlineNode::VerbatimText(Verbatim {
                content: "let x = 1; ".to_string(),
                location: Location::default(),
            }),
            create_callout_ref(1),
            InlineNode::VerbatimText(Verbatim {
                content: "\nlet y = 2; ".to_string(),
                location: Location::default(),
            }),
            create_callout_ref(2),
        ];

        let mut buffer = Vec::new();
        highlight_code(
            &mut buffer,
            &inlines,
            "rust",
            DEFAULT_THEME_LIGHT,
            HighlightMode::Inline,
        )?;

        let html = String::from_utf8(buffer).expect("valid utf8");
        assert!(
            html.contains("<i class=\"conum\" data-value=\"1\"></i><b>(1)</b>"),
            "Should contain callout 1 HTML, got: {html}"
        );
        assert!(
            html.contains("<i class=\"conum\" data-value=\"2\"></i><b>(2)</b>"),
            "Should contain callout 2 HTML, got: {html}"
        );
        assert!(
            !html.contains("&lt;1&gt;"),
            "Callouts should not appear as escaped text: {html}"
        );

        Ok(())
    }

    #[test]
    #[allow(clippy::expect_used)]
    fn test_highlight_rust_code() -> Result<(), Error> {
        let code = "fn main() {\n    println!(\"Hello, world!\");\n}";
        let inlines = create_verbatim_inlines(code);

        let mut buffer = Vec::new();
        highlight_code(
            &mut buffer,
            &inlines,
            "rust",
            DEFAULT_THEME_LIGHT,
            HighlightMode::Inline,
        )?;

        let html = String::from_utf8(buffer).expect("valid utf8");
        assert!(
            html.contains("<span"),
            "Should produce highlighted output with spans"
        );

        Ok(())
    }

    #[test]
    #[allow(clippy::expect_used)]
    fn test_highlight_unknown_language_fallback() -> Result<(), Error> {
        let code = "some code here";
        let inlines = create_verbatim_inlines(code);

        let mut buffer = Vec::new();
        highlight_code(
            &mut buffer,
            &inlines,
            "unknown_lang_xyz",
            DEFAULT_THEME_LIGHT,
            HighlightMode::Inline,
        )?;

        let html = String::from_utf8(buffer).expect("valid utf8");
        assert!(
            !html.is_empty(),
            "Should produce output even with unknown language"
        );
        // With giallo's fallback_to_plain, it renders as plain text with spans
        assert!(
            html.contains("some code here"),
            "Should contain the original text, got: {html}"
        );

        Ok(())
    }

    #[test]
    #[allow(clippy::expect_used)]
    fn test_highlight_class_mode_produces_class_spans() -> Result<(), Error> {
        let code = "fn main() {}";
        let inlines = create_verbatim_inlines(code);

        let mut buffer = Vec::new();
        highlight_code(
            &mut buffer,
            &inlines,
            "rust",
            DEFAULT_THEME_LIGHT,
            HighlightMode::Class,
        )?;

        let html = String::from_utf8(buffer).expect("valid utf8");
        assert!(
            html.contains("class=\"syntax-"),
            "Class mode should produce class= spans, got: {html}"
        );
        assert!(
            !html.contains("style="),
            "Class mode should not produce style= attributes, got: {html}"
        );
        Ok(())
    }

    #[test]
    #[allow(clippy::expect_used)]
    fn test_highlight_class_mode_with_callouts() -> Result<(), Error> {
        let inlines = vec![
            InlineNode::VerbatimText(Verbatim {
                content: "let x = 1; ".to_string(),
                location: Location::default(),
            }),
            create_callout_ref(1),
            InlineNode::VerbatimText(Verbatim {
                content: "\nlet y = 2; ".to_string(),
                location: Location::default(),
            }),
            create_callout_ref(2),
        ];

        let mut buffer = Vec::new();
        highlight_code(
            &mut buffer,
            &inlines,
            "rust",
            DEFAULT_THEME_LIGHT,
            HighlightMode::Class,
        )?;

        let html = String::from_utf8(buffer).expect("valid utf8");
        assert!(
            html.contains("<i class=\"conum\" data-value=\"1\"></i><b>(1)</b>"),
            "Class mode should preserve callouts, got: {html}"
        );
        assert!(
            html.contains("<i class=\"conum\" data-value=\"2\"></i><b>(2)</b>"),
            "Class mode should preserve callouts, got: {html}"
        );
        Ok(())
    }

    #[test]
    fn test_highlight_css_generates_stylesheet() -> Result<(), Error> {
        let css = highlight_css(DEFAULT_THEME_LIGHT)?;
        assert!(
            css.contains(".syntax-"),
            "CSS should contain .syntax- prefixed rules, got: {css}"
        );
        assert!(css.contains("color:"), "CSS should contain color rules");
        Ok(())
    }

    #[test]
    fn test_highlight_css_custom_theme() -> Result<(), Error> {
        let css = highlight_css("catppuccin-frappe")?;
        assert!(css.contains(".syntax-"));
        Ok(())
    }

    #[test]
    fn test_highlight_css_unknown_theme_errors() {
        let result = highlight_css("nonexistent-theme");
        assert!(result.is_err());
    }
}
