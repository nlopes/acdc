//! Syntax highlighting for source code blocks using syntect.
//!
//! This module provides syntax highlighting for code blocks when the
//! `highlighting` feature is enabled. It supports two output modes:
//!
//! - **Inline** (default): `<span style="color:#...">` — themes baked into HTML
//! - **Class**: `<span class="syntax-keyword">` — themes applied via CSS classes
//!
//! The mode is controlled by the `:syntect-css:` document attribute.
//!
//! # Callout Handling
//!
//! Code blocks may contain callout references (e.g., `<1>`, `<2>`) that need
//! to be rendered as HTML elements, not as part of the highlighted code.
//! We track callout positions during text extraction and inject the proper
//! HTML (`<i class="conum" data-value="N"></i><b>(N)</b>`) after highlighting.

use std::{collections::HashMap, io::Write};

use acdc_parser::InlineNode;

use crate::Error;

/// Default light theme.
pub(crate) const DEFAULT_THEME_LIGHT: &str = "InspiredGitHub";
/// Default dark theme.
pub(crate) const DEFAULT_THEME_DARK: &str = "base16-eighties.dark";

/// How syntax-highlighted spans are styled in the HTML output.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub(crate) enum HighlightMode {
    /// Inline `style="color:…"` attributes (default, backward-compatible).
    #[default]
    Inline,
    /// CSS class names (`class="syntax-keyword"`) — requires a `<style>` block
    /// generated by [`highlight_css`].
    Class,
}

/// The `ClassStyle` used for class-based output.  Every scope token is
/// prefixed with `syntax-` so the generated classes don't collide with
/// the rest of the page's styles.
#[cfg(feature = "highlighting")]
const SYNTAX_CLASS_STYLE: syntect::html::ClassStyle =
    syntect::html::ClassStyle::SpacedPrefixed { prefix: "syntax-" };

/// Highlight code and write HTML output.
///
/// When the `highlighting` feature is enabled, this uses syntect for syntax
/// highlighting. The `mode` parameter controls whether inline styles or CSS
/// classes are emitted. Otherwise, it outputs plain escaped text.
///
/// Callout references are preserved and rendered as proper HTML elements
/// after the highlighted code on each line.
#[cfg(feature = "highlighting")]
pub(crate) fn highlight_code<W: Write + ?Sized>(
    writer: &mut W,
    inlines: &[InlineNode],
    language: &str,
    theme_name: &str,
    mode: HighlightMode,
) -> Result<(), Error> {
    let (code, callouts) = extract_text_and_callouts(inlines);
    let syntax_set = syntect::parsing::SyntaxSet::load_defaults_newlines();

    let syntax = syntax_set
        .find_syntax_by_token(language)
        .or_else(|| syntax_set.find_syntax_by_extension(language))
        .unwrap_or_else(|| syntax_set.find_syntax_plain_text());

    match mode {
        HighlightMode::Inline => highlight_code_inline(
            writer,
            &code,
            &callouts,
            inlines,
            &syntax_set,
            syntax,
            theme_name,
        ),
        HighlightMode::Class => {
            highlight_code_classed(writer, &code, &callouts, &syntax_set, syntax)
        }
    }
}

/// Inline-style highlighting (existing behaviour).
#[cfg(feature = "highlighting")]
fn highlight_code_inline<W: Write + ?Sized>(
    writer: &mut W,
    code: &str,
    callouts: &HashMap<usize, usize>,
    inlines: &[InlineNode],
    syntax_set: &syntect::parsing::SyntaxSet,
    syntax: &syntect::parsing::SyntaxReference,
    theme_name: &str,
) -> Result<(), Error> {
    use syntect::{highlighting::ThemeSet, html::highlighted_html_for_string};

    let theme_set = ThemeSet::load_defaults();
    let Some(theme) = theme_set.themes.get(theme_name) else {
        return write_escaped_code_with_callouts(writer, inlines);
    };

    let html = highlighted_html_for_string(code, syntax_set, syntax, theme)
        .map_err(|e| Error::Io(std::io::Error::other(e)))?;

    // syntect wraps output in <pre style="..."> which we don't want
    // since we already have our own <pre> wrapper. Extract just the inner content.
    let content = extract_inner_content(&html);

    if callouts.is_empty() {
        write!(writer, "{content}")?;
    } else {
        let output = insert_callouts_into_highlighted_html(content, callouts);
        write!(writer, "{output}")?;
    }

    Ok(())
}

/// Class-based highlighting using `ClassedHTMLGenerator`.
#[cfg(feature = "highlighting")]
fn highlight_code_classed<W: Write + ?Sized>(
    writer: &mut W,
    code: &str,
    callouts: &HashMap<usize, usize>,
    syntax_set: &syntect::parsing::SyntaxSet,
    syntax: &syntect::parsing::SyntaxReference,
) -> Result<(), Error> {
    use syntect::html::ClassedHTMLGenerator;

    let mut generator =
        ClassedHTMLGenerator::new_with_class_style(syntax, syntax_set, SYNTAX_CLASS_STYLE);
    for line in syntect::util::LinesWithEndings::from(code) {
        generator
            .parse_html_for_line_which_includes_newline(line)
            .map_err(|e| Error::Io(std::io::Error::other(e)))?;
    }
    let html = generator.finalize();

    if callouts.is_empty() {
        write!(writer, "{html}")?;
    } else {
        let output = insert_callouts_into_classed_html(&html, callouts);
        write!(writer, "{output}")?;
    }

    Ok(())
}

/// Generate a CSS stylesheet for class-based syntax highlighting.
///
/// Returns the CSS rules that map `.syntax-*` classes to the colours of
/// the given theme. Embed this in a `<style>` block in the `<head>`.
#[cfg(feature = "highlighting")]
pub(crate) fn highlight_css(theme_name: &str) -> Result<String, Error> {
    use syntect::{highlighting::ThemeSet, html::css_for_theme_with_class_style};

    let theme_set = ThemeSet::load_defaults();
    let theme = theme_set.themes.get(theme_name).ok_or_else(|| {
        Error::Io(std::io::Error::other(format!(
            "unknown syntect theme: {theme_name}"
        )))
    })?;

    css_for_theme_with_class_style(theme, SYNTAX_CLASS_STYLE)
        .map_err(|e| Error::Io(std::io::Error::other(e)))
}

/// Extract the inner content from syntect's inline-style HTML output.
/// Syntect wraps everything in `<pre style="...">...</pre>`, but we want just the spans.
#[cfg(feature = "highlighting")]
fn extract_inner_content(html: &str) -> &str {
    let start = html.find('>').map_or(0, |i| i + 1);
    let end = html.rfind("</pre>").unwrap_or(html.len());
    html.get(start..end).unwrap_or(html)
}

/// Insert callout HTML at the appropriate line endings in inline-style highlighted code.
///
/// Note: syntect's inline output may have a leading newline which we need to skip
/// when counting lines.
#[cfg(feature = "highlighting")]
fn insert_callouts_into_highlighted_html(html: &str, callouts: &HashMap<usize, usize>) -> String {
    let mut result = String::with_capacity(html.len() + callouts.len() * 50);

    let has_leading_newline = html.starts_with('\n');

    for (i, line) in html.split('\n').enumerate() {
        if i > 0 {
            result.push('\n');
        }

        let code_line_num = if has_leading_newline && i > 0 {
            i - 1
        } else if has_leading_newline {
            result.push_str(line);
            continue;
        } else {
            i
        };

        result.push_str(line);
        if let Some(&callout_num) = callouts.get(&code_line_num) {
            use std::fmt::Write;
            let _ = write!(
                result,
                " <i class=\"conum\" data-value=\"{callout_num}\"></i><b>({callout_num})</b>"
            );
        }
    }

    result
}

/// Insert callout HTML into class-based highlighted code.
///
/// The class-based generator does NOT emit a leading newline, so line
/// counting is straightforward.
#[cfg(feature = "highlighting")]
fn insert_callouts_into_classed_html(html: &str, callouts: &HashMap<usize, usize>) -> String {
    let mut result = String::with_capacity(html.len() + callouts.len() * 50);

    for (i, line) in html.split('\n').enumerate() {
        if i > 0 {
            result.push('\n');
        }
        result.push_str(line);
        if let Some(&callout_num) = callouts.get(&i) {
            use std::fmt::Write;
            let _ = write!(
                result,
                " <i class=\"conum\" data-value=\"{callout_num}\"></i><b>({callout_num})</b>"
            );
        }
    }

    result
}

/// HTML-escape special characters.
fn html_escape(s: &str) -> String {
    s.replace('&', "&amp;")
        .replace('<', "&lt;")
        .replace('>', "&gt;")
        .replace('"', "&quot;")
}

/// Write HTML-escaped code with callout markers.
///
/// This is the fallback when syntax highlighting is disabled or unavailable.
fn write_escaped_code_with_callouts<W: Write + ?Sized>(
    writer: &mut W,
    inlines: &[InlineNode],
) -> Result<(), Error> {
    let (code, callouts) = extract_text_and_callouts(inlines);

    if callouts.is_empty() {
        let escaped = html_escape(&code);
        write!(writer, "{escaped}")?;
    } else {
        for (i, line) in code.split('\n').enumerate() {
            if i > 0 {
                writeln!(writer)?;
            }
            let escaped = html_escape(line);
            write!(writer, "{escaped}")?;
            if let Some(&callout_num) = callouts.get(&i) {
                write!(
                    writer,
                    "<i class=\"conum\" data-value=\"{callout_num}\"></i><b>({callout_num})</b>"
                )?;
            }
        }
    }
    Ok(())
}

/// Highlight code when the highlighting feature is not enabled.
#[cfg(not(feature = "highlighting"))]
pub(crate) fn highlight_code<W: Write + ?Sized>(
    writer: &mut W,
    inlines: &[InlineNode],
    _language: &str,
    _theme_name: &str,
    _mode: HighlightMode,
) -> Result<(), Error> {
    write_escaped_code_with_callouts(writer, inlines)
}

/// Extract text content and callout positions from inline nodes for highlighting.
///
/// Returns the code text (without callout markers) and a map of line numbers
/// to callout numbers.
fn extract_text_and_callouts(inlines: &[InlineNode]) -> (String, HashMap<usize, usize>) {
    let mut result = String::new();
    let mut callouts: HashMap<usize, usize> = HashMap::new();
    let mut current_line = 0;

    for node in inlines {
        #[allow(clippy::match_same_arms)]
        match node {
            InlineNode::VerbatimText(verbatim) => {
                for ch in verbatim.content.chars() {
                    result.push(ch);
                    if ch == '\n' {
                        current_line += 1;
                    }
                }
            }
            InlineNode::RawText(raw) => {
                for ch in raw.content.chars() {
                    result.push(ch);
                    if ch == '\n' {
                        current_line += 1;
                    }
                }
            }
            InlineNode::PlainText(plain) => {
                for ch in plain.content.chars() {
                    result.push(ch);
                    if ch == '\n' {
                        current_line += 1;
                    }
                }
            }
            InlineNode::LineBreak(_) => {
                result.push('\n');
                current_line += 1;
            }
            InlineNode::CalloutRef(callout) => {
                callouts.insert(current_line, callout.number);
            }
            InlineNode::BoldText(_)
            | InlineNode::ItalicText(_)
            | InlineNode::MonospaceText(_)
            | InlineNode::HighlightText(_)
            | InlineNode::SubscriptText(_)
            | InlineNode::SuperscriptText(_)
            | InlineNode::CurvedQuotationText(_)
            | InlineNode::CurvedApostropheText(_)
            | InlineNode::StandaloneCurvedApostrophe(_)
            | InlineNode::InlineAnchor(_)
            | InlineNode::Macro(_) => {}
            node => {
                tracing::warn!(
                    ?node,
                    "this type of node is not yet implemented for code highlighting"
                );
            }
        }
    }
    (result, callouts)
}

#[cfg(all(test, feature = "highlighting"))]
mod tests {
    use super::*;
    use acdc_parser::{CalloutRef, CalloutRefKind, Location, Verbatim};

    fn create_verbatim_inlines(content: &str) -> Vec<InlineNode> {
        vec![InlineNode::VerbatimText(Verbatim {
            content: content.to_string(),
            location: Location::default(),
        })]
    }

    fn create_callout_ref(number: usize) -> InlineNode {
        InlineNode::CalloutRef(CalloutRef {
            kind: CalloutRefKind::Explicit,
            number,
            location: Location::default(),
        })
    }

    #[test]
    fn test_extract_text_and_callouts_from_verbatim() {
        let inlines = create_verbatim_inlines("fn main() {\n    println!(\"Hello\");\n}");
        let (text, callouts) = extract_text_and_callouts(&inlines);
        assert_eq!(text, "fn main() {\n    println!(\"Hello\");\n}");
        assert!(callouts.is_empty());
    }

    #[test]
    fn test_extract_text_and_callouts_with_callouts() {
        let inlines = vec![
            InlineNode::VerbatimText(Verbatim {
                content: "let x = 1; ".to_string(),
                location: Location::default(),
            }),
            create_callout_ref(1),
            InlineNode::VerbatimText(Verbatim {
                content: "\nlet y = 2; ".to_string(),
                location: Location::default(),
            }),
            create_callout_ref(2),
            InlineNode::VerbatimText(Verbatim {
                content: "\n".to_string(),
                location: Location::default(),
            }),
        ];

        let (text, callouts) = extract_text_and_callouts(&inlines);
        assert_eq!(text, "let x = 1; \nlet y = 2; \n");
        assert_eq!(callouts.get(&0), Some(&1));
        assert_eq!(callouts.get(&1), Some(&2));
        assert_eq!(callouts.len(), 2);
    }

    #[test]
    #[allow(clippy::expect_used)]
    fn test_highlight_code_with_callouts() -> Result<(), Error> {
        let inlines = vec![
            InlineNode::VerbatimText(Verbatim {
                content: "let x = 1; ".to_string(),
                location: Location::default(),
            }),
            create_callout_ref(1),
            InlineNode::VerbatimText(Verbatim {
                content: "\nlet y = 2; ".to_string(),
                location: Location::default(),
            }),
            create_callout_ref(2),
        ];

        let mut buffer = Vec::new();
        highlight_code(
            &mut buffer,
            &inlines,
            "rust",
            DEFAULT_THEME_LIGHT,
            HighlightMode::Inline,
        )?;

        let html = String::from_utf8(buffer).expect("valid utf8");
        assert!(
            html.contains("<i class=\"conum\" data-value=\"1\"></i><b>(1)</b>"),
            "Should contain callout 1 HTML, got: {html}"
        );
        assert!(
            html.contains("<i class=\"conum\" data-value=\"2\"></i><b>(2)</b>"),
            "Should contain callout 2 HTML, got: {html}"
        );
        assert!(
            !html.contains("&lt;1&gt;"),
            "Callouts should not appear as escaped text: {html}"
        );

        Ok(())
    }

    #[test]
    #[allow(clippy::expect_used)]
    fn test_highlight_rust_code() -> Result<(), Error> {
        let code = "fn main() {\n    println!(\"Hello, world!\");\n}";
        let inlines = create_verbatim_inlines(code);

        let mut buffer = Vec::new();
        highlight_code(
            &mut buffer,
            &inlines,
            "rust",
            DEFAULT_THEME_LIGHT,
            HighlightMode::Inline,
        )?;

        let html = String::from_utf8(buffer).expect("valid utf8");
        assert!(
            html.contains("<span"),
            "Should produce highlighted output with spans"
        );

        Ok(())
    }

    #[test]
    #[allow(clippy::expect_used)]
    fn test_highlight_unknown_language_fallback() -> Result<(), Error> {
        let code = "some code here";
        let inlines = create_verbatim_inlines(code);

        let mut buffer = Vec::new();
        highlight_code(
            &mut buffer,
            &inlines,
            "unknown_lang_xyz",
            DEFAULT_THEME_LIGHT,
            HighlightMode::Inline,
        )?;

        assert!(
            !buffer.is_empty(),
            "Should produce output even with unknown language"
        );
        assert_eq!(
            std::str::from_utf8(&buffer).expect("valid utf8"),
            "\n<span style=\"color:#323232;\">some code here</span>"
        );
        Ok(())
    }

    #[test]
    #[allow(clippy::expect_used)]
    fn test_highlight_class_mode_produces_class_spans() -> Result<(), Error> {
        let code = "fn main() {}";
        let inlines = create_verbatim_inlines(code);

        let mut buffer = Vec::new();
        highlight_code(
            &mut buffer,
            &inlines,
            "rust",
            DEFAULT_THEME_LIGHT,
            HighlightMode::Class,
        )?;

        let html = String::from_utf8(buffer).expect("valid utf8");
        assert!(
            html.contains("class=\"syntax-"),
            "Class mode should produce class= spans, got: {html}"
        );
        assert!(
            !html.contains("style="),
            "Class mode should not produce style= attributes, got: {html}"
        );
        Ok(())
    }

    #[test]
    #[allow(clippy::expect_used)]
    fn test_highlight_class_mode_with_callouts() -> Result<(), Error> {
        let inlines = vec![
            InlineNode::VerbatimText(Verbatim {
                content: "let x = 1; ".to_string(),
                location: Location::default(),
            }),
            create_callout_ref(1),
            InlineNode::VerbatimText(Verbatim {
                content: "\nlet y = 2; ".to_string(),
                location: Location::default(),
            }),
            create_callout_ref(2),
        ];

        let mut buffer = Vec::new();
        highlight_code(
            &mut buffer,
            &inlines,
            "rust",
            DEFAULT_THEME_LIGHT,
            HighlightMode::Class,
        )?;

        let html = String::from_utf8(buffer).expect("valid utf8");
        assert!(
            html.contains("<i class=\"conum\" data-value=\"1\"></i><b>(1)</b>"),
            "Class mode should preserve callouts, got: {html}"
        );
        assert!(
            html.contains("<i class=\"conum\" data-value=\"2\"></i><b>(2)</b>"),
            "Class mode should preserve callouts, got: {html}"
        );
        Ok(())
    }

    #[test]
    fn test_highlight_css_generates_stylesheet() -> Result<(), Error> {
        let css = highlight_css(DEFAULT_THEME_LIGHT)?;
        assert!(
            css.contains(".syntax-"),
            "CSS should contain .syntax- prefixed rules, got: {css}"
        );
        assert!(css.contains("color:"), "CSS should contain color rules");
        Ok(())
    }

    #[test]
    fn test_highlight_css_custom_theme() -> Result<(), Error> {
        let css = highlight_css("base16-ocean.dark")?;
        assert!(css.contains(".syntax-"));
        Ok(())
    }

    #[test]
    fn test_highlight_css_unknown_theme_errors() {
        let result = highlight_css("nonexistent-theme");
        assert!(result.is_err());
    }
}
