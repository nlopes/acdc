//! Document-level rendering for manpages.
//!
//! Handles the `.TH` title header macro and document preamble.

use std::io::Write;

use acdc_converters_common::visitor::WritableVisitor;
use acdc_parser::{AttributeValue, Document, InlineNode};

use crate::{Error, ManpageVisitor, escape::escape_quoted};

/// Extract plain text from inline nodes (for code blocks, title parsing, etc.).
pub fn extract_plain_text(nodes: &[InlineNode]) -> String {
    let mut result = String::new();
    for node in nodes {
        match node {
            InlineNode::PlainText(text) => result.push_str(&text.content),
            InlineNode::RawText(text) => result.push_str(&text.content),
            InlineNode::VerbatimText(text) => result.push_str(&text.content),
            InlineNode::BoldText(bold) => result.push_str(&extract_plain_text(&bold.content)),
            InlineNode::ItalicText(italic) => result.push_str(&extract_plain_text(&italic.content)),
            InlineNode::MonospaceText(mono) => result.push_str(&extract_plain_text(&mono.content)),
            InlineNode::HighlightText(highlight) => {
                result.push_str(&extract_plain_text(&highlight.content));
            }
            InlineNode::SubscriptText(sub) => result.push_str(&extract_plain_text(&sub.content)),
            InlineNode::SuperscriptText(sup) => result.push_str(&extract_plain_text(&sup.content)),
            InlineNode::CurvedQuotationText(quoted) => {
                result.push_str(&extract_plain_text(&quoted.content));
            }
            InlineNode::CurvedApostropheText(quoted) => {
                result.push_str(&extract_plain_text(&quoted.content));
            }
            // These nodes don't contribute plain text (and future variants via wildcard)
            // InlineNode is #[non_exhaustive], so wildcard arm handles future variants
            #[allow(clippy::match_same_arms, clippy::wildcard_enum_match_arm)]
            InlineNode::StandaloneCurvedApostrophe(_)
            | InlineNode::LineBreak(_)
            | InlineNode::InlineAnchor(_)
            | InlineNode::Macro(_)
            | _ => {}
        }
    }
    result
}

/// Visit document start - generates the .TH header and preamble.
///
/// Reads manpage attributes that were derived by the parser:
/// - `mantitle`: The program name from the document title
/// - `manvolnum`: The volume number from the document title
/// - `manname`: From NAME section (or falls back to mantitle)
/// - `manpurpose`: From NAME section (after ` - `)
pub fn visit_document_start<W: Write>(
    doc: &Document,
    visitor: &mut ManpageVisitor<W>,
) -> Result<(), Error> {
    // Ensure we have a header
    if doc.header.is_none() {
        return Err(Error::MissingHeader);
    }

    // Get mantitle and manvolnum from document attributes (set by parser)
    let mantitle = doc
        .attributes
        .get_string("mantitle")
        .ok_or_else(|| Error::InvalidManpageTitle("missing mantitle attribute".to_string()))?;

    let manvolnum = doc
        .attributes
        .get_string("manvolnum")
        .unwrap_or(String::from("1"));

    // Copy parser-derived attributes to visitor for use during conversion.
    // These are already set by the parser (from NAME section), but we need
    // to ensure they're in the visitor's attribute map for rendering.
    let attrs = &mut visitor.processor.document_attributes;

    // manname: from parser (NAME section) or fall back to mantitle
    if let Some(manname) = doc.attributes.get_string("manname") {
        attrs.insert("manname".to_string(), AttributeValue::String(manname));
    } else {
        attrs.insert(
            "manname".to_string(),
            AttributeValue::String(mantitle.clone()),
        );
    }

    // manpurpose: from parser (NAME section), if available
    if let Some(manpurpose) = doc.attributes.get_string("manpurpose") {
        attrs.insert("manpurpose".to_string(), AttributeValue::String(manpurpose));
    }

    // Get optional attributes (user-provided or defaults)
    let mansource = doc.attributes.get_string("mansource").unwrap_or_default();
    let manmanual = doc.attributes.get_string("manmanual").unwrap_or_default();

    // Get date - use revdate attribute or current date
    let date = doc
        .attributes
        .get_string("revdate")
        .unwrap_or(chrono::Local::now().format("%Y-%m-%d").to_string());

    let w = visitor.writer_mut();

    // Write comment header (enables tbl preprocessor)
    writeln!(w, r#"'\" t"#)?;
    writeln!(w, r#".\"  Generated by acdc"#)?;

    // Write .TH macro
    // Format: .TH "NAME" "VOLUME" "DATE" "SOURCE" "MANUAL"
    writeln!(
        w,
        ".TH \"{}\" \"{}\" \"{}\" \"{}\" \"{}\"",
        escape_quoted(&mantitle.to_uppercase()),
        escape_quoted(&manvolnum),
        escape_quoted(&date),
        escape_quoted(&mansource),
        escape_quoted(&manmanual)
    )?;

    // Write preamble settings (targeting modern groff)
    writeln!(w, r#".\" Disable hyphenation"#)?;
    writeln!(w, ".nh")?;
    writeln!(w, r#".\" Left-align only"#)?;
    writeln!(w, ".ad l")?;

    Ok(())
}
